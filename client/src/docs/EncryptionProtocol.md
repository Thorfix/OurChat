# RetroChat End-to-End Encryption Protocol

## Overview

RetroChat implements a comprehensive end-to-end encryption (E2EE) protocol to ensure that only the intended recipients can read private messages. This document describes the technical implementation, security properties, and verification methods used in our encryption system.

## Key Features

- **Asymmetric Encryption**: RSA-OAEP with 2048-bit keys for secure key exchange
- **Symmetric Encryption**: AES-GCM (256-bit) for efficient message encryption
- **Key Verification**: Fingerprint-based verification similar to Signal's safety numbers
- **Key Rotation**: Automatic key rotation to limit the impact of potential compromise
- **Secure Key Backup**: Password-protected backup and recovery system
- **Forward Secrecy**: New symmetric keys for each message
- **Ephemeral Messages**: Support for self-destructing messages

## Encryption Flow

1. **Key Generation**:
   - Each user generates an RSA-2048 key pair during initialization
   - Public keys are stored on the server; private keys never leave the client
   - Keys have configurable expiration dates (default: 30 days)

2. **Message Encryption**:
   - For each message, a random AES-256 key is generated
   - The message is encrypted with this symmetric key using AES-GCM
   - The symmetric key is then encrypted with the recipient's public RSA key
   - Both the encrypted message and the encrypted symmetric key are sent to the server

3. **Message Decryption**:
   - The recipient decrypts the symmetric key using their private RSA key
   - The message is then decrypted using the symmetric key
   - The original message is never stored unencrypted on the server

## Key Verification

To prevent man-in-the-middle attacks, users can verify each other's encryption keys:

1. **Safety Numbers**:
   - Each public key generates a unique fingerprint
   - Fingerprints are displayed in both hexadecimal and numeric formats
   - Users can compare these fingerprints through another channel (in person, phone call, etc.)

2. **Verification Process**:
   - Both users compare each other's key fingerprints
   - If they match exactly, the communication is secure
   - Once verified, the status is saved locally
   - Visual indicators show which conversations are verified

## Key Rotation and Expiration

To limit the impact of potential key compromise:

1. **Automatic Expiration**:
   - Keys have a configurable lifetime (default: 30 days)
   - The UI shows warnings when keys are nearing expiration
   - Keys can be rotated at any time manually

2. **Rotation Process**:
   - New key pairs are generated to replace expiring ones
   - The server maintains a history of public keys
   - Messages are always encrypted with the recipient's most recent active key

## Secure Key Backup

To prevent loss of encrypted messages when changing devices:

1. **Backup Creation**:
   - Keys are encrypted with a user-provided password using PBKDF2 and AES-GCM
   - The encrypted backup can be saved to external storage
   - Backup data includes salt, IV, and version information for future compatibility

2. **Key Restoration**:
   - Users provide the backup data and password
   - After restoration, the keys are verified to ensure integrity
   - Restored keys are re-registered with the server

## Technical Details

### RSA Key Generation

```javascript
const RSA_ALGORITHM = {
  name: 'RSA-OAEP',
  modulusLength: 2048,
  publicExponent: new Uint8Array([1, 0, 1]), // 65537
  hash: 'SHA-256',
};
```

### AES Message Encryption

```javascript
const AES_ALGORITHM = {
  name: 'AES-GCM',
  length: 256,
};
```

### Fingerprint Generation

Key fingerprints are generated by:
1. Extracting the RSA modulus component
2. Hashing it with SHA-256
3. Converting to a readable format (both hex and numeric)

### Password-based Key Derivation (for backups)

```javascript
{
  name: 'PBKDF2',
  salt: salt,
  iterations: 100000,
  hash: 'SHA-256'
}
```

## Security Considerations

1. **Browser Security**:
   - The Web Crypto API is used for all cryptographic operations
   - All operations occur in the user's browser
   - Private keys never leave client memory

2. **Forward Secrecy**:
   - Each message uses a fresh symmetric key
   - Compromising one message doesn't compromise others

3. **Server Knowledge**:
   - The server only sees encrypted content
   - Metadata (sender, recipient, timestamp) is not encrypted

4. **Key Verification**:
   - Manual verification is required to prevent MITM attacks
   - Visual indicators show verification status

5. **Error Handling**:
   - Cryptographic errors are sanitized to prevent information leakage
   - Users receive actionable guidance without exposing sensitive details

## Limitations

1. **Browser Storage**:
   - Keys are stored in localStorage, which has persistence limitations
   - Users should create backups for critical conversations

2. **No Perfect Forward Secrecy**:
   - Unlike protocols like Signal, we don't implement ratcheting for PFS
   - Key rotation provides some forward secrecy guarantees

3. **Metadata**:
   - While message content is encrypted, metadata is not
   - The server knows who is communicating with whom

## Implementation Status

- ✅ Asymmetric/symmetric hybrid encryption
- ✅ Key verification via safety numbers
- ✅ Key rotation and expiration
- ✅ Secure key backup and recovery
- ✅ Ephemeral messages
- ✅ Visual security indicators
- ✅ Comprehensive testing

## Future Enhancements

- ⏳ Double Ratchet Algorithm for perfect forward secrecy
- ⏳ Multi-device support with synchronized keys
- ⏳ Encrypted metadata
- ⏳ Post-quantum cryptography readiness

## For Security Researchers

If you discover any vulnerabilities or have suggestions for improving our encryption protocol, please contact us at security@retrochat.example.com. We welcome security audits and feedback from the community.

---

Last updated: July 2023